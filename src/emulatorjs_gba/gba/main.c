#include "main.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "gba.h"
/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
#include "images/title.h"
#include "images/win.h"
#include "images/lose.h"
#include "images/tank.h"
#include "images/hourglass.h"

/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.
enum gba_state {
  START,
  PLAY,
  WIN,
  LOSE,
};

int collide(int x1, int y1, int w1, int h1, int x2, int y2, int w2, int h2) {
  if (x1 > x2 + w2 || x1 + w1 < x2 || y1 > y2 + h2 || y1 + h1 < y2) {
    return 0;
  } else {
    return 1;
  }
}

int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //
  REG_DISPCNT = MODE3 | BG2_ENABLE;

  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;

  // Load initial application state
  enum gba_state state = START;

  //create player
  struct player player;
  player.highest_kill = 0;
  int has_draw_health = 0;
  int has_draw_kill = 0;
  int num_jump = 0;

  //create gun
  struct gun gun;

  //create bullet
  int has_shoot;    
  struct bullet bullet;

  //create creature
  int num_creature = 3;
  int has_spawn_new_creature = 1;
  struct creature creatures[MAX_CREATURE];
  struct position creatures_pos[MAX_CREATURE], creatures_prev_pos[MAX_CREATURE];
  for(int i = 0; i < MAX_CREATURE; i++) {
    creatures[i].alive = 0;
    creatures[i].health = 10;
    creatures[i].damage = 1;
    creatures[i].speed = 1;
    creatures[i].curr = &creatures_pos[i];
    creatures[i].prev = &creatures_prev_pos[i];
  }
  int creature_evolve = 0;

  //Animation for title
  int draw_full_screen = 0;
  int ani_frame_timer = 0;
  int ani_timer = 1;
  int has_draw_text = 0;

  struct position tank_pos, tank_prev_pos;
  tank_pos.row = HEIGHT - 8 - TANK_HEIGHT;
  tank_pos.col = 0;

  //WIN screen
  int draw_background = 0;

  //Text
  char timer_buffer[10];
  char health_buffer[10];
  char time_left_buffer[10];
  char kill_buffer[50];

  //Timer
  int frame_timer = 0;
  int timer = 60;

  //Position
  struct position player_pos, player_prev_pos, gun_pos, gun_prev_pos, bullet_curr, bullet_prev;    

  while (1) {
    currentButtons = BUTTONS; // Load the current state of the buttons

    //save the draw state for player
    player.prev = &player_prev_pos;
    player.prev->row = player.curr->row;
    player.prev->col = player.curr->col;

    //save the draw state for the gun
    player.gun->gun_prev = &gun_prev_pos;
    player.gun->gun_prev->row = player.gun->gun_curr->row;
    player.gun->gun_prev->col = player.gun->gun_curr->col;

    //save the draw state for the bullet
    player.gun->bullet->bullet_prev = &bullet_prev;
    player.gun->bullet->bullet_prev->row = player.gun->bullet->bullet_curr->row;
    player.gun->bullet->bullet_prev->col = player.gun->bullet->bullet_curr->col;

    //save the draw state for creature
    for(int i = 0; i < MAX_CREATURE; i++) {
      creatures[i].prev->row = creatures[i].curr->row;
      creatures[i].prev->col = creatures[i].curr->col;
    }

    //save the draw state for tank
    tank_prev_pos.row = tank_pos.row;
    tank_prev_pos.col = tank_pos.col;

    /* TODO: */
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw
    switch (state) {
      case START:
      //Draw Blank Screen
        waitForVBlank();
        if (draw_full_screen == 0) {
          drawFullScreenImageDMA(title_background);
          draw_full_screen = 1;
        }

      //Animation
        undrawImageDMA(tank_prev_pos.row, tank_prev_pos.col, TANK_WIDTH, TANK_HEIGHT, title_background);
        tank_pos.col++;
        drawImageDMA(tank_pos.row, tank_pos.col, TANK_WIDTH, TANK_HEIGHT, tank);
        if (tank_pos.col > WIDTH) {
          tank_pos.col = 0;
        }

        ani_frame_timer++;
        if (ani_frame_timer > 60) {
          ani_frame_timer = 0;
          ani_timer--;
        }
        if (ani_timer <= 0) {
          ani_timer = 1;
          if (has_draw_text == 0) {
            has_draw_text = 1;
          } else {
            has_draw_text = 0;
          }
        }

        drawRectDMA(HEIGHT - 8 - 2, 0, WIDTH, 8 + 2, BLACK);
        //START STR
        if (has_draw_text == 0) {
          drawCenteredString(HEIGHT - 8 - 2, WIDTH/2, 10, 10, "PRESS START TO PLAY", WHITE);
        } else if (has_draw_text == 1) {
          drawRectDMA(HEIGHT - 8 - 2, 0, WIDTH, 8 + 2, BLACK);
        }

        if (KEY_DOWN(BUTTON_START, currentButtons)) {

          draw_full_screen = 0;
          ani_frame_timer = 0;
          ani_timer = 1;
          has_draw_text = 0;
          has_draw_health = 0;
          has_draw_kill = 0;

          waitForVBlank();
          fillScreenDMA(BLACK);
          //init player
          player.kill = 0;
          player.health = 3;
          player.speed = 2;
          player.curr = &player_pos;
          player.curr->row = HEIGHT/2;
          player.curr->col = WIDTH/2;

          //init gun
          player.gun = &gun;
          player.gun->heading = 0;
          player.gun->gun_width = 4;
          player.gun->gun_height = 4;
          player.gun->gun_curr = &gun_pos;

          //init bullet
          player.gun->bullet = &bullet;
          player.gun->bullet->alive = 0;
          player.gun->bullet->vel = 5;
          player.gun->bullet->size = 2;
          player.gun->bullet->damage = 10;

          //init creature
          for (int i = 0; i < num_creature; i++) {
            creatures[i].alive = 1;
            int rand_row = randint(0, 2);
            int rand_col = randint(0, 2);
            
            if (rand_row == 0) {
              creatures[i].curr->row = randint(8 + 2, HEIGHT/2 - 20);
            } else {
              creatures[i].curr->row = randint(HEIGHT/2 + 20, HEIGHT - sprite_size - 1);
              
            }
            if (rand_col == 0) {
              creatures[i].curr->col = randint(0 + 1, WIDTH/2 - 10);
            } else {
              creatures[i].curr->col = randint(WIDTH/2 + 10, WIDTH - 1 - sprite_size);
            }

          }

          //Pre-print Timer
          waitForVBlank();
          snprintf(timer_buffer, 10, "TIME:%d", timer);
          drawString(1, 10, timer_buffer, WHITE);
          drawImageDMA(1, 10 * 6 - 5, 8, 8, hourglass);

          //Change State
          state = PLAY;
        }
        break;

      case PLAY:
//--------------------------------------------------------------------WALLS-------------------------------------------------------------------------------
        waitForVBlank();

        //Wall Bound

          //LEFT WALL
        for(int r = 9; r < HEIGHT; r++) {
          setPixel(r, 0, BLUE);
        }

          //RIGHT WALL
        for(int r = 9; r < HEIGHT; r++) {
          setPixel(r, WIDTH - 1, BLUE);
        }

          //UP WALL
        for(int c = 0; c < WIDTH; c++) {
          setPixel(9, c, BLUE);
        }

          //BOTTOM WALL
        for(int c = 0; c < WIDTH; c++) {
          setPixel(HEIGHT - 1, c, BLUE);
        }

//----------------------------------------------------------------------TEXT---------------------------------------------------------------------
        waitForVBlank();
        //Timer
        frame_timer++;
        if (frame_timer == 60) {
          timer--;
          frame_timer = 0;
          waitForVBlank();
          drawRectDMA(1, 0, 100, 8, BLACK);
          snprintf(timer_buffer, 10, "TIME:%d", timer);
          drawString(1, 10, timer_buffer, WHITE);
          drawImageDMA(1, 10 * 6 - 5, 8, 8, hourglass);
          if (timer % 2 == 0) {
            has_spawn_new_creature = 0;
          }
        }
        if (timer <= 0) {
          waitForVBlank();
          drawRectDMA(0, 0, WIDTH, HEIGHT, BLACK);
          state = WIN;
        }

        //Health
        snprintf(health_buffer, 10, "HEALTH:%d", player.health);
        if (has_draw_health == 0) {
          waitForVBlank();
          drawRectDMA(0, WIDTH/2, 50, 9, BLACK);
          drawCenteredString(1, WIDTH/2, 8, 8, health_buffer, WHITE);
          has_draw_health = 1;
        }

        //Kill
        snprintf(kill_buffer, 10, "KILL:%d", player.kill);
        if (has_draw_kill == 0) {
          waitForVBlank();
          drawRectDMA(0, WIDTH - 50, 50, 9, BLACK);
          drawCenteredString(1, WIDTH - 50, 8, 8, kill_buffer, WHITE);
          has_draw_health = 1;
        }
        
//---------------------------------------------------------------------CREATURE---------------------------------------------------------------------
        //Creature Spawn Control
        if (has_spawn_new_creature == 0 && num_creature < MAX_CREATURE) {
          int spawn_num = randint(1, 6);

          if (num_creature + spawn_num > MAX_CREATURE) {
            spawn_num = MAX_CREATURE - num_creature;
          }

          int sn = spawn_num;

          for (int i = 0; i < MAX_CREATURE; i++) {
            if (creatures[i].alive == 0 && sn > 0) {
              creatures[i].alive = 1;
              int rand_row = randint(0, 2);
              int rand_col = randint(0, 2);
              
              if (rand_row == 0) {
                creatures[i].curr->row = randint(8 + 2, HEIGHT/2 - 20);
              } else {
                creatures[i].curr->row = randint(HEIGHT/2 + 20, HEIGHT - sprite_size - 1);
                
              }
              if (rand_col == 0) {
                creatures[i].curr->col = randint(0 + 1, WIDTH/2 - 10);
              } else {
                creatures[i].curr->col = randint(WIDTH/2 + 10, WIDTH - 1);
              }
              num_creature++;
              sn--;
              if (spawn_num <= 0) {
                break;
              }
            }

          }
          has_spawn_new_creature = 1;
        }

        //Creature movement
        for(int i = 0; i < MAX_CREATURE; i++) {
          if (creatures[i].alive == 1) {
            int distance_to_player_x = player.curr->row - creatures[i].curr->row;
            int distance_to_player_y = player.curr->col - creatures[i].curr->col;

            if (distance_to_player_x > 0) {
              creatures[i].curr->row += creatures[i].speed;
            } else if (distance_to_player_x < 0) {
              creatures[i].curr->row -= creatures[i].speed;
            }

            if (distance_to_player_y > 0) {
              creatures[i].curr->col += creatures[i].speed;
            } else if (distance_to_player_y < 0) {
              creatures[i].curr->col -= creatures[i].speed;
            }
          }
        }

        //Creature evolve
        if ((num_jump >= 3 || timer <= 20) && creature_evolve == 0) {
          creature_evolve = 1;
          for(int i = 0; i < MAX_CREATURE; i++) {
            creatures[i].speed += 2;
          } 
        }     

//-----------------------------------------------------------------------PLAYER----------------------------------------------------------------------
        //Player Inputs
          //BACK TO START SCREEN
        if (KEY_DOWN(BUTTON_SELECT, currentButtons)) {

          draw_full_screen = 0;
          ani_frame_timer = 0;
          ani_timer = 1;
          has_draw_text = 0;
          frame_timer = 0;
          timer = 60;
          num_creature = 3;
          has_spawn_new_creature = 1;
          draw_background = 0;
          frame_timer = 0;
          timer = 60;
          tank_pos.row = HEIGHT - 8 - 2 - TANK_HEIGHT;
          tank_pos.col = 0;
          creature_evolve = 0;
          num_jump = 0;
          has_draw_health = 0;
          has_draw_kill = 0;

          drawRectDMA(0, 0, WIDTH, HEIGHT, BLACK);
          draw_full_screen = 0;

          for(int i = 0; i < MAX_CREATURE; i++) {
            creatures[i].alive = 0;
            creatures[i].health = 10;
            creatures[i].damage = 1;
            creatures[i].speed = 1;
          }

          player.gun->bullet->alive = 0;
          player.gun->bullet->bullet_curr->row = 0;
          player.gun->bullet->bullet_curr->col = 0;

          state = START;
        }

          //Player Movement
        if (KEY_DOWN(BUTTON_RIGHT, currentButtons)) {
          player.curr->col += player.speed;
        }
        if (KEY_DOWN(BUTTON_LEFT, currentButtons)) {
          player.curr->col -= player.speed;
        }

        if (KEY_DOWN(BUTTON_UP, currentButtons)) {
          player.curr->row -= player.speed;
        }
        if (KEY_DOWN(BUTTON_DOWN, currentButtons)) {
          player.curr->row += player.speed;
        }

          //Teleport/Jump Control
        if (KEY_JUST_PRESSED(BUTTON_B, currentButtons, previousButtons)) {
          switch (player.gun->heading) {
            case 0:
              player.curr->row -= PLAYER_JUMP_DISTANCE;
              break;
            case 1:
              player.curr->col += PLAYER_JUMP_DISTANCE;
              break;
            case 2:
              player.curr->row += PLAYER_JUMP_DISTANCE;
              break;
            case 3:
              player.curr->col -= PLAYER_JUMP_DISTANCE;
              break;
          }
          num_jump++;
        }

        //Checking Bounds
        int rightBound = WIDTH - sprite_size - 1;
        int leftBound = 0 + 1;
        int upBound = 0 + 8 + 2;
        int bottomBound = HEIGHT - sprite_size - 1;

        switch (player.gun->heading) {
            case 0:
              upBound += 4;
              break;
            case 1:
              rightBound -= 4;
              break;
            case 2:
              bottomBound -= 4;
              break;
            case 3:
              leftBound += 4;
              break;
          }

        if (player.curr->col > rightBound) {
          player.curr->col = rightBound;
        }
        if (player.curr->col < leftBound) {
          player.curr->col = leftBound;
        }

        if (player.curr->row < upBound) {
          player.curr->row = upBound;
        }
        if (player.curr->row > bottomBound) {
          player.curr->row = bottomBound;
        }

        //Gun Control
        if (KEY_JUST_PRESSED(BUTTON_L, currentButtons, previousButtons)) {
          player.gun->heading--;
          if (player.gun->heading < 0) {
            player.gun ->heading = 3;
          }
        }
        if (KEY_JUST_PRESSED(BUTTON_R, currentButtons, previousButtons)) {
          player.gun->heading++;
          if (player.gun->heading > 3) {
            player.gun->heading = 0;
          }
        }

        player.gun->gun_prev->row = player.gun->gun_curr->row;
        player.gun->gun_prev->col = player.gun->gun_curr->col;
        switch (player.gun->heading) {
          case 0:
            player.gun->gun_curr->row = player.curr->row - player.gun->gun_height;
            player.gun->gun_curr->col = ((player.curr->col + sprite_size/2)) - player.gun->gun_width/2;
            break;
          case 1:
            player.gun->gun_curr->row = ((player.curr->row + sprite_size/2)) - player.gun->gun_height/2;
            player.gun->gun_curr->col = player.curr->col + sprite_size;
            break;
          case 2:
            player.gun->gun_curr->row = player.curr->row + sprite_size;
            player.gun->gun_curr->col = ((player.curr->col + sprite_size/2)) - player.gun->gun_width/2;
            break;
          case 3:
            player.gun->gun_curr->row = ((player.curr->row + sprite_size/2)) - player.gun->gun_height/2;
            player.gun->gun_curr->col = player.curr->col - player.gun->gun_width;
            break;
        }

        //Shoot Control
        if (KEY_DOWN(BUTTON_A, currentButtons) && has_shoot == 0) {
          has_shoot = 1;
          player.gun->bullet->bullet_curr = &bullet_curr;
          player.gun->bullet->alive = 1;
          switch (player.gun->heading) {
            case 0:
            case 2:
              player.gun->bullet->bullet_curr->row = player.gun->gun_curr->row;
              player.gun->bullet->bullet_curr->col = player.gun->gun_curr->col + (player.gun->bullet->size / 2);
              break;
            case 1:
            case 3:
              player.gun->bullet->bullet_curr->row = player.gun->gun_curr->row + (player.gun->bullet->size / 2);
              player.gun->bullet->bullet_curr->col = player.gun->gun_curr->col;
              break;
          }
        }

        //Bullet Movement
        player.gun->bullet->bullet_prev->row = player.gun->bullet->bullet_curr->row;
        player.gun->bullet->bullet_prev->col = player.gun->bullet->bullet_curr->col;
        if (has_shoot == 1) {
          switch (player.gun->heading) {
            case 0:
              player.gun->bullet->bullet_curr->row -= player.gun->bullet->vel;
              break;
            case 1:
              player.gun->bullet->bullet_curr->col += player.gun->bullet->vel;
              break;
            case 2:
              player.gun->bullet->bullet_curr->row += player.gun->bullet->vel;
              break;
            case 3:
              player.gun->bullet->bullet_curr->col -= player.gun->bullet->vel;
              break;
          }
        }

        //Checking Bullet Bounds
        if (player.gun->bullet->bullet_curr->col > WIDTH - player.gun->bullet->size - 1) {
          player.gun->bullet->bullet_curr->col = WIDTH - player.gun->bullet->size - 1;
        }
        if (player.gun->bullet->bullet_curr->col < 0 + 1) {
          player.gun->bullet->bullet_curr->col = 0 + 1;
        }

        if (player.gun->bullet->bullet_curr->row < 0 + 8 + 2) {
          player.gun->bullet->bullet_curr->row = 0 + 8 + 2;
        }
        if (player.gun->bullet->bullet_curr->row > HEIGHT - player.gun->bullet->size - 1) {
          player.gun->bullet->bullet_curr->row = HEIGHT - player.gun->bullet->size - 1;
        }

//---------------------------------------------------------------------Collision---------------------------------------------------------------------
          //If creature hit the player, player health - creature damage
        for (int i = 0; i < MAX_CREATURE; i++) {
          if (collide(player.curr->col, player.curr->row, sprite_size, sprite_size, creatures[i].curr->col, creatures[i].curr->row, sprite_size, sprite_size) == 1) {
            if (creatures[i].alive == 1) {
              player.health -= creatures[i].damage;
              if (player.health <= 0) {
                state = LOSE;
              }

              has_draw_health = 0;

              if (player.curr->row > creatures[i].curr->row) {
                player.curr->row += 5;
              } else if (player.curr->row < creatures[i].curr->row) {
                player.curr->row -= 5;
              }

              if (player.curr->col > creatures[i].curr->col) {
                player.curr->col += 5;
              } else if (player.curr->col < creatures[i].curr->col) {
                player.curr->col -= 5;
              }
            }
          }
        }
        
          //If bullet hit the creature, creature health - bullet damage
        for (int i = 0; i < MAX_CREATURE; i++) {
          if (creatures[i].alive == 1 && player.gun->bullet->alive == 1 && 
              collide(player.gun->bullet->bullet_curr->row, player.gun->bullet->bullet_curr->col, player.gun->bullet->size, player.gun->bullet->size, 
                creatures[i].curr->row, creatures[i].curr->col, sprite_size, sprite_size) == 1) {
            player.gun->bullet->alive = 0;
            has_shoot = 0;
            creatures[i].health -= player.gun->bullet->damage;
            if (creatures[i].health <= 0) {
              creatures[i].alive = 0;
              drawRectDMA(creatures[i].prev->row, creatures[i].prev->col, sprite_size, sprite_size, BLACK);
              drawRectDMA(creatures[i].curr->row, creatures[i].curr->col, sprite_size, sprite_size, BLACK);
              num_creature--;
              player.kill++;
              if (player.kill > player.highest_kill) {
                player.highest_kill = player.kill;
              }
              has_draw_kill = 0;
            }
          }
        }

          //If bullet hit the wall, delete the bullet
        if ((player.gun->bullet->bullet_curr->col <= 0 + 1) || (player.gun->bullet->bullet_curr->col >= WIDTH - player.gun->bullet->size - 1) ||
            (player.gun->bullet->bullet_curr->row <= 0 + 8 + 2) || (player.gun->bullet->bullet_curr->row >= HEIGHT - player.gun->bullet->size - 1)) {
          player.gun->bullet->alive = 0;
          has_shoot = 0;
        }
//--------------------------------------------------------------------DRAW SPRITE-------------------------------------------------------------------
        waitForVBlank();

        //Undraw
        drawRectDMA(player.prev->row, player.prev->col, sprite_size, sprite_size, BLACK);
        drawRectDMA(player.gun->gun_prev->row, player.gun->gun_prev->col, player.gun->gun_width, player.gun->gun_height, BLACK);
        drawRectDMA(player.gun->bullet->bullet_prev->row, player.gun->bullet->bullet_prev->col, player.gun->bullet->size, player.gun->bullet->size, BLACK);
        for(int i = 0; i < MAX_CREATURE; i++) {
          if (creatures[i].alive == 1) {
            drawRectDMA(creatures[i].prev->row, creatures[i].prev->col, sprite_size, sprite_size, BLACK);
          }
        }

        //Draw
        drawRectDMA(player.curr->row, player.curr->col, sprite_size, sprite_size, GREEN);
        drawRectDMA(player.gun->gun_curr->row, player.gun->gun_curr->col, player.gun->gun_width, player.gun->gun_height, GREEN);
        if (has_shoot == 1) {
          drawRectDMA(player.gun->bullet->bullet_curr->row, player.gun->bullet->bullet_curr->col, player.gun->bullet->size, player.gun->bullet->size, YELLOW);
        }
        for(int i = 0; i < MAX_CREATURE; i++) {
          if (creatures[i].alive == 1) {
            if (creature_evolve == 0) {
              drawRectDMA(creatures[i].curr->row, creatures[i].curr->col, sprite_size, sprite_size, RED);
            } else if (creature_evolve == 1) {
              drawRectDMA(creatures[i].curr->row, creatures[i].curr->col, sprite_size, sprite_size, MAGENTA);
            }
          }
        }

        break;

      case WIN:
      //Draw Background
        if (draw_background == 0) {
          drawImageDMA(0, 0, WIDTH, HEIGHT, win);
          draw_background = 1;
        }

      //Animation
        ani_frame_timer++;
        if (ani_frame_timer > 60) {
          ani_frame_timer = 0;
          ani_timer--;
        }
        if (ani_timer <= 0) {
          ani_timer = 1;
          if (has_draw_text == 0) {
            has_draw_text = 1;
          } else {
            has_draw_text = 0;
          }
        }

      //Text Display
        if (has_draw_text == 0) {
          drawCenteredString(HEIGHT - 8 - 2, WIDTH/2, 10, 10, "PRESS SELECT TO PLAY AGAIN", WHITE);
        } else if (has_draw_text == 1) {
          drawRectDMA(HEIGHT - 8 - 2, 0, WIDTH, 8 + 2, BLACK);
        }

        waitForVBlank();
        drawCenteredString(2, WIDTH/2, 10, 10, "YOU SURVIVE", WHITE);
        snprintf(kill_buffer, 50, "KILLS: %d (HIGHEST KILLS: %d)", player.kill, player.highest_kill);
        drawCenteredString(12, WIDTH/2, 10, 10, kill_buffer, WHITE);

      //BACK TO START SCREEN
        if (KEY_DOWN(BUTTON_SELECT, currentButtons)) {

          draw_full_screen = 0;
          ani_frame_timer = 0;
          ani_timer = 1;
          has_draw_text = 0;
          frame_timer = 0;
          timer = 60;
          num_creature = 3;
          has_spawn_new_creature = 1;
          draw_background = 0;
          frame_timer = 0;
          timer = 60;
          tank_pos.row = HEIGHT - 8 - 2 - TANK_HEIGHT;
          tank_pos.col = 0;
          creature_evolve = 0;
          num_jump = 0;
          has_draw_health = 0;
          has_draw_kill = 0;

          drawRectDMA(0, 0, WIDTH, HEIGHT, BLACK);
          draw_full_screen = 0;

          for(int i = 0; i < MAX_CREATURE; i++) {
            creatures[i].alive = 0;
            creatures[i].health = 10;
            creatures[i].damage = 1;
            creatures[i].speed = 1;
          }

          player.gun->bullet->alive = 0;
          player.gun->bullet->bullet_curr->row = 0;
          player.gun->bullet->bullet_curr->col = 0;

          state = START;
        }
        break;

      case LOSE:
      //Draw Background
        if (draw_background == 0) {
          drawImageDMA(0, 0, WIDTH, HEIGHT, lose);
          draw_background = 1;
        }
      
      //Animation
        ani_frame_timer++;
        if (ani_frame_timer > 60) {
          ani_frame_timer = 0;
          ani_timer--;
        }
        if (ani_timer <= 0) {
          ani_timer = 1;
          if (has_draw_text == 0) {
            has_draw_text = 1;
          } else {
            has_draw_text = 0;
          }
        }
      
      //Text Display
        if (has_draw_text == 0) {
          drawCenteredString(HEIGHT - 8 - 2, WIDTH/2, 10, 10, "PRESS SELECT TO PLAY AGAIN", WHITE);
        } else if (has_draw_text == 1) {
          drawRectDMA(HEIGHT - 8 - 2, 0, WIDTH, 8 + 2, BLACK);
        }

        waitForVBlank();
        drawCenteredString(2, WIDTH/2, 10, 10, "YOU DIE! BETTER LUCK NEXT TIME!", WHITE);
        
        drawString(HEIGHT/2 - 5, 0, "TIME LEFT", WHITE);
        snprintf(time_left_buffer, 10, "%d", timer);
        drawString(HEIGHT/2 + 5, 25, time_left_buffer, WHITE);

        drawString(HEIGHT/2 - 5, WIDTH - 50, "KILLS", WHITE);
        snprintf(kill_buffer, 10, "%d", player.kill);
        drawString(HEIGHT/2 + 5, WIDTH - 40, kill_buffer, WHITE);

        snprintf(kill_buffer, 50, "HIGHEST KILLS: %d", player.highest_kill);
        drawCenteredString(HEIGHT - 18, WIDTH/2, 10, 10, kill_buffer, WHITE);

      //BACK TO START SCREEN
        if (KEY_DOWN(BUTTON_SELECT, currentButtons)) {

          draw_full_screen = 0;
          ani_frame_timer = 0;
          ani_timer = 1;
          has_draw_text = 0;
          frame_timer = 0;
          timer = 60;
          num_creature = 3;
          has_spawn_new_creature = 1;
          draw_background = 0;
          frame_timer = 0;
          timer = 60;
          tank_pos.row = HEIGHT - 8 - 2 - TANK_HEIGHT;
          tank_pos.col = 0;
          creature_evolve = 0;
          num_jump = 0;
          has_draw_health = 0;
          has_draw_kill = 0;

          drawRectDMA(0, 0, WIDTH, HEIGHT, BLACK);
          draw_full_screen = 0;

          for(int i = 0; i < MAX_CREATURE; i++) {
            creatures[i].alive = 0;
            creatures[i].health = 10;
            creatures[i].damage = 1;
            creatures[i].speed = 1;
          }

          player.gun->bullet->alive = 0;
          player.gun->bullet->bullet_curr->row = 0;
          player.gun->bullet->bullet_curr->col = 0;

          state = START;
        }
        break;
    }
    previousButtons = currentButtons; // Store the current state of the buttons
  }
  return 0;
}
